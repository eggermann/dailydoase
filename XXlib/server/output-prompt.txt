 --> test.cjs :
 require('./index.cjs').init();

store.cjs :
const fs = require("fs");
const path = require("path");

// The in-memory cache structure, e.g.:
// {
//   "folderName": [
//       {
//         "file": "someimage.png",
//         "ext": ".png",
//         "fullPath": "...",
//         "mtime": Date(),
//         "jsonPath": "..."
//       },
//       ...
//   ],
//   ...
// }
let _cache = Object.create(null);

// We'll store the base imgPath here so we can use it in addFile, etc.
let _imgPath = "";

/**
 * Scans a folder (absolute path) for image files (.png).
 * Returns an array of file meta info objects.
 */
function scanFolderForImages(folderAbsolutePath) {
    const folderFiles = fs.readdirSync(folderAbsolutePath).filter((fileName) => {
        const fullPath = path.join(folderAbsolutePath, fileName);
        const stats = fs.lstatSync(fullPath);
        return stats.isFile() && fileName.toLowerCase().endsWith(".png");
    });

    return folderFiles.map((fileName) => {
        const fullPath = path.join(folderAbsolutePath, fileName);
        const stats = fs.lstatSync(fullPath);
        return {
            file: fileName,
            ext: path.extname(fileName),
            fullPath,
            mtime: stats.mtime,
            jsonPath: fullPath.replace(".png", ".json"),
        };
    });
}

/**
 * Initialize the entire cache by scanning every subfolder of `imgPath`
 */
function initCache(imgPath) {
    // Store reference for later use in addFile, etc.
    _imgPath = imgPath;
    _cache = {}; // reset

    const items = fs.readdirSync(imgPath, { withFileTypes: true });
    // subfolders only (skip files)
    const subfolders = items.filter((dirent) => dirent.isDirectory()).map((d) => d.name);

    subfolders.forEach((folderName) => {
        const folderAbsolutePath = path.join(imgPath, folderName);
        const images = scanFolderForImages(folderAbsolutePath);
        if (images.length) {
            _cache[folderName] = images;
        }
    });
}

/**
 * (Optional) Refresh entire cache if you expect many changes and
 * want to keep the directory listing up-to-date.
 */
function refreshCache() {
    if (!_imgPath) {
        throw new Error("refreshCache() called before initCache()!");
    }
    initCache(_imgPath);
}

/**
 * Retrieve the entire cache
 */
function getCache() {
    return _cache;
}

/**
 * Retrieve array of file metadata for a given folderName
 */
function getFolder(folderName) {
    return _cache[folderName] || [];
}

/**
 * Add a single file (e.g., "myImage.png") in a given folderName
 * to the in-memory _cache. Assumes the file already exists on disk.
 *
 * @param {string} folderName - e.g. "v-1__bak"
 * @param {string} fileName   - e.g. "myImage.png"
 */
function addFile(folderName, fileName) {
    if (!_imgPath) {
        throw new Error("addFile() called before initCache()!");
    }

    const folderAbsolutePath = path.join(_imgPath, folderName);
    const fileAbsolutePath = path.join(folderAbsolutePath, fileName);

    // Verify the file actually exists and is .png
    if (!fs.existsSync(fileAbsolutePath)) {
        console.warn(`addFile: File does not exist: ${fileAbsolutePath}`);
        return;
    }
    if (!fileName.toLowerCase().endsWith(".png")) {
        console.warn(`addFile: Not a PNG, skipping: ${fileName}`);
        return;
    }

    const stats = fs.lstatSync(fileAbsolutePath);
    if (!stats.isFile()) {
        console.warn(`addFile: Path is not a file, skipping: ${fileAbsolutePath}`);
        return;
    }

    // Make sure the folder is in _cache
    if (!_cache[folderName]) {
        _cache[folderName] = [];
    }

    // Remove any existing entry for fileName, in case we are overwriting
    _cache[folderName] = _cache[folderName].filter((item) => item.file !== fileName);

    // Insert the new metadata object
    _cache[folderName].push({
        file: fileName,
        ext: path.extname(fileName),
        fullPath: fileAbsolutePath,
        mtime: stats.mtime,
        jsonPath: fileAbsolutePath.replace(".png", ".json"),
    });

    console.log(`addFile: Added "${fileName}" to folder "${folderName}" in _cache.`);
}

// Export the store API
module.exports = {
    initCache,
    refreshCache,
    getCache,
    getFolder,
    addFile,     // <--- NEW
};

routes.cjs :
const express = require('express');
const router = express.Router();

// Define your routes here
router.get('/', (req, res) => {
    res.send('Hello, world!');
});

module.exports = router;

index.cjs :
const express = require("express");
const path = require("path");
const fs = require("fs");
const Handlebars = require("handlebars");
const bodyParser = require("body-parser");
// Import the store itself
const store = require("./store.cjs");

const cors = require("cors");
const app = express();
app.use(cors());

const _ = require("./functions.cjs");
const routes = require('./routes.cjs');

const router = express.Router();
const baseUrl = "https://dailydoase.de";
const port = 4000;
const __ = { dailymotionCnt: 0, youtubeCnt: 0, maxJsonFiles: 20 };
// Initialize the store at startup
const imgPath = path.join(__dirname, "../images");
store.initCache(imgPath);
app.use('/', routes);

const routes = [
    {
        "/youtube": async (req, res) => {
            const folderPath = path.join(__dirname, "../../youtube");
            _.ensureDirectoryExists(folderPath);
            __.getNext();
            fs.readdir(folderPath, (err, files) => {
                if (err) {
                    console.error("Error reading folder:", err);
                    return res.status(500).send("Internal Server Error");
                }
                const fileStats = files
                    .map((file) => {
                        const filePath = path.join(folderPath, file);
                        const stats = fs.statSync(filePath);
                        return { file, stats };
                    })
                    .filter((item) => item.stats.isFile());
                fileStats.sort((a, b) => b.stats.mtime - a.stats.mtime);
                if (fileStats.length === 0) {
                    return res.status(404).send("No files found in the folder");
                }
                const pos = fileStats.length - 1 - ((__.youtubeCnt++) % fileStats.length);
                const actFile = fileStats[pos].file;
                const filePath = path.join(folderPath, actFile);
                res.download(filePath, (err) => {
                    if (err) {
                        console.error("Error sending file:", err);
                        return res.status(500).send("Internal Server Error");
                    }
                });
            });
        },
    },
    {
        "/dailymotion": async (req, res) => {
            const folderPath = path.join(__dirname, "../../dailymotion");
            _.ensureDirectoryExists(folderPath);
            fs.readdir(folderPath, (err, files) => {
                if (err) {
                    console.error("Error reading folder:", err);
                    return res.status(500).send("Internal Server Error");
                }
                const fileStats = files
                    .map((file) => {
                        const filePath = path.join(folderPath, file);
                        let stats = null;
                        try {
                            stats = fs.statSync(filePath);
                        } catch (e) {}
                        return { file, stats };
                    })
                    .filter((item) => item.stats && item.stats.isFile());
                fileStats.sort((a, b) => b.stats.mtime - a.stats.mtime);
                if (fileStats.length > __.maxJsonFiles) {
                    const delta = fileStats.length - __.maxJsonFiles;
                    for (let i = 0; i <= delta; i++) {
                        const jsonFilm = fileStats.pop();
                        const deleteFile = folderPath + "/" + jsonFilm.file;
                        console.log(deleteFile);
                        fs.unlinkSync(deleteFile);
                        console.log("gelöscht: ", deleteFile);
                    }
                } else {
                    __.getNext();
                }
                if (fileStats.length === 0) {
                    return res.status(404).send("No files found in the folder");
                }
                const pos = fileStats.length - 1 - ((__.dailymotionCnt++) % fileStats.length);
                const actFile = fileStats[pos].file;
                const filePath = path.join(folderPath, actFile);
                res.download(filePath, (err) => {
                    if (err) {
                        console.error("Error sending file:", err);
                        return res.status(500).send("Internal Server Error");
                    }
                });
            });
        },
    },
    {
        "/rnd": async (req, res) => {
            let folder = req.query.version || _.getRandomFolder();
            _.ensureDirectoryExists(folder);
            if (folder == "newest") {}
            const imageP = _.getRandomImage(folder);
            if (!imageP) {
                console.log("----->err no such img ");
                return;
            }
            console.log("----->rnd ", imageP);
            const image = await fs.promises.readFile(imageP, { encoding: "base64" });
            const img = Buffer.from(image, "base64");
            res.writeHead(200, {
                "Content-Type": "image/png",
                "Content-Length": img.length,
            });
            res.end(img);
        },
    },
    {
        "/": (req, res) => {
            res.set("content-type", "text/html");
            const menu = _.createMenu(path.join(__dirname, "./../../images"));
            const template = _.getHomeTemplate();
            const data = { menu, isHome: true };
            const result = "<!DOCTYPE html> " + template(data);
            res.send(result);
        },
    },
    {
        "/img": async (req, res) => {
            const data = await _.mostRecentFileOrFolder();
            if (false && data.json == (_.oldDatas && _.oldDatas.json)) {
                const dataHistorical = await _.mostRecentFileOrFolder(_.cnt++);
                res.json(dataHistorical);
            } else {
                _.oldDatas = data;
                res.json(data);
            }
        },
    },
    {
        "/daily-doasis": (req, res) => {
            res.redirect("https://dailydoase.de/");
        },
    },
    {
        "/v/:version/": (req, res) => {
            const indexHtml = fs.readFileSync(path.join(__dirname, "../web/dist/index-template.hbs"), "utf-8");
            const template = Handlebars.compile(indexHtml);
            const actFolderName = req.params.version;
            if (actFolderName == "newest") {}
            const autoplay = req.query.autoplay != null ? 1 : 0;
            const menu = _.createMenu(path.join(__dirname, "./../../images"), actFolderName);
            let images = _.getAllFilesFromFolderForImages("/" + actFolderName);
            let infoJson = images[0].json;

            if ( req.query.sort == "desc") {
                images=images.reverse();
            }

            const data = { menu, images, pageClass: "folder", autoplay, infoJson };
            if (typeof req.query.frame == "string") {
                data.frame = true;
            }
            const result = "<!DOCTYPE html> " + template(data);
            res.send(result);
        },
    },
    {
        "/v/:version/:img/": async (req, res) => {
            const url = "/" + req.params.version + "/" + req.params.img;
            const suffix = path.parse(req.params.img).ext;
            if (suffix == ".json") {
                const json = _.getJSON(url);
                const imageUrl = "/v" + url.replace(".json", ".png");
                const wordsSentence = json.words.map((i) => i[0]).join("-");
                const nftMeta = {
                    name: wordsSentence,
                    description: json.prompt,
                    image: baseUrl + imageUrl,
                };
                res.json(nftMeta);
                return;
            }
            const images = await _.getFile("/" + req.params.version + "/" + req.params.img);
            const img = Buffer.from(images, "base64");
            res.writeHead(200, {
                "Content-Type": "image/png",
                "Content-Length": img.length,
            });
            res.end(img);
        },
    },
    {
        "/v/:version/:img/img": async (req, res) => {
            const images = await _.getFile("/" + req.params.version + "/" + req.params.img);
            const img = Buffer.from(images, "base64");
            res.writeHead(200, {
                "Content-Type": "image/png",
                "Content-Length": img.length,
            });
            res.end(img);
        },
    },
];
module.exports.init = (getNext) => {
    app.use(express.static(path.join(__dirname, "../web/dist")));
    __.getNext = getNext;
    _.registerPartials(path.join(__dirname, "./partials"));
    routes.forEach((r) => {
        const route = Object.keys(r)[0];
        const meth = r[route];
        router.get(route, meth);
    });

    app.use("", router);
    app.listen(port, "0.0.0.0", () => {
        console.log(`http://0.0.0.0:${port}/`);
    });
};


helpers.cjs :
const path = require("path");
const os = require("os");

const isValidPartial = (file) => {
    return path.extname(file) === ".hbs";
};

const isOnServer = () => {
    const userHomeDir = os.homedir();
    //console.log('on uberspace ------>', userHomeDir, '<-------', (userHomeDir.indexOf('eggman') != -1))
    return (userHomeDir.indexOf('eggman') != -1);
};

module.exports = {
    isValidPartial,
    isOnServer,
};

functions.cjs :
const path = require("path");
const fs = require("fs");
const routes = require("./index.cjs");
const handlebars = require("handlebars");
const imgPath = path.join(__dirname, '../images');
const { isValidPartial, isOnServer } = require("./helpers.cjs");

const store = require("./store.cjs"); // <-- reference to our in-memory cache module

// Initialize the file-path cache at startup
// Using the same imgPath as in functions.cjs

store.initCache(imgPath);

// rest of your code ...
// e.g. app.use('/', routes);

// For demonstration, suppose you want to see your cache
app.get("/debug-cache", (req, res) => {
    const data = store.getCache();
    res.json(data);
});

const _ = {
    getImageTemplate(){

  // @TODO
        let indexHtml = fs.readFileSync(path.join(__dirname, './../web/dist/index-template.hbs'), 'utf-8');
        _.registerPartials(path.join(__dirname, './partials'));

        const homeTemplate = handlebars.compile(indexHtml);
        return homeTemplate;
    },
    getHomeTemplate: () => {
        let indexHtml = fs.readFileSync(path.join(__dirname, './../web/dist/index-template.hbs'), 'utf-8');
        _.registerPartials(path.join(__dirname, './partials'));

        const homeTemplate = handlebars.compile(indexHtml);
        return homeTemplate;
    },
    registerPartials: (partialsFolder) => {
       // console.log(partialsFolder, 'partialsFolder')

        fs.readdirSync(partialsFolder)
            .filter(isValidPartial)
            .forEach(partial => {
                const ext = path.extname(partial);

                const fileFullPath = path.join(partialsFolder, partial)
                const data = fs.readFileSync(fileFullPath, 'utf-8')

                // Store as `"filename without extension": content`.
                handlebars.registerPartial(path.basename(partial, ext), data);
            })
    },
    getJSON(dir) {

        try {
            const p = path.join( imgPath, dir);
            return require(p, 'utf-8');
        }catch (e){
            console.log('getJSON error-->',e)
            return {}
        }
    },
    async getFile(dir) {
        try {
            const p = path.join(imgPath, dir);
            return await fs.promises.readFile(p, {encoding: 'base64'});

        }catch (e){
            console.log('getFile error-->',e)
            return JSON.stringify(e)
        }
     },
    /**
     * Example function that fetches PNG files (and JSON metadata) from a folder
     * but uses the in-memory store instead of scanning the disk each time.
     *
     * @param {string} dir e.g. "/v-1__bak"
     * @returns {Array} array of objects like { href, json, mtime }
     */
    getAllFilesFromFolderForImages(dir = "v-1__bak") {
        // remove leading slash if present
        const folderName = dir.replace("/", "");
        // get metadata array from the store
        const cachedData = store.getFolder(folderName); // e.g. [ { file, fullPath, mtime, ... }, ...]

        // Transform each item to match your original usage
        return cachedData.map((metaObj) => {
            let href = "/v" + dir + "/" + metaObj.file;
            let json = { name: metaObj.file };

            // Optionally read the .json file if it exists
            try {
                // metaObj.jsonPath might be something like "/.../myImage.json"
                Object.assign(json, require(metaObj.jsonPath));
            } catch (err) {
                // no .json or failed to read
            }

            return {
                href,
                json,
                mtime: metaObj.mtime.getTime(),
            };
        });
    },
    getRandomImage: (folder) => {
        const folderP = folder;// path.join(p, folder);

        try {
            const images = fs.readdirSync(folderP).filter(file => {
                const lstat = fs.lstatSync(path.join(folderP, file));
                return (lstat.isFile() && file.indexOf('.png') != -1);
            })

            const rndImg = images[Math.floor(Math.random() * images.length)];
            return path.join(folderP, rndImg)
        } catch (err) {
            console.log('getRandomImage err ', err);

            return null;
        }

    },
    getRandomFolder: () => {
        let files = fs.readdirSync(imgPath).filter(file => {
            return fs.lstatSync(path.join(imgPath, file)).isDirectory()
        });

        return p + '/' + files[Math.floor(Math.random() * files.length - 1)];
    },
    /**
     * Create a "menu" of subfolders from the store
     */
    createMenu(dir, actFolderName = "/") {
        const allFolders = Object.keys(store.getCache()); // e.g. ["v-1__bak","v-2",...]

        // map them to your menu structure
        let menu = allFolders.map((folder) => {
            // each folder has array of images in store
            const fileCnt = store.getFolder(folder).length;
            const current = actFolderName === folder;
            // build href
            let href = "/v/" + folder;
            if (isOnServer()) {
                // if you have some special prefix on your server, handle it here
                // e.g.: href = "/daily-doasis" + href;
            }
            return { href, name: folder, fileCnt, current };
        });

        // add home link at top
        let homeHref = "/";
        if (isOnServer()) {
            // homeHref = "/daily-doasis"; // if needed
        }

        // only include folders with at least 1 file
        menu = menu.filter((i) => i.fileCnt >= 1);

        // prepend 'Home'
        menu = [{ href: homeHref, name: "Home", current: actFolderName == "/" }].concat(
            menu
        );

        return menu;
    },

    /**
     * Example function to add a new file to the store's cache
     * once the file is written to disk.
     */
    addNewFileToCache(folderName, fileName) {
        store.addFile(folderName, fileName);
    },

    orderRecentFiles(dir, returnFiles) {

        return fs.readdirSync(dir).filter(file => {

            const lstat = fs.lstatSync(path.join(dir, file));
            const isFile = lstat.isFile();

            if (returnFiles) {
                if (isFile) {

                    if (file.indexOf('.png') != -1) {

                        return true;
                    }

                    return false;
                }
                return false;
            } else {
                return !isFile;
            }
        }).map((file) => ({file, mtime: fs.lstatSync(path.join(dir, file)).mtime}))
            .sort((a, b) => b.mtime.getTime() - a.mtime.getTime());
    },
    getMostRecentPNGFileOrFolder(dir, returnFiles, indexImage = 0) {
        const files = _.orderRecentFiles(dir, returnFiles);

        indexImage %= files.length;
        return files.length ? files[indexImage] : undefined;
    },
    mostRecentFileOrFolder: async (indexImage) => {
        let contents = '', json = {};

        try {
            const folderName = _.getMostRecentPNGFileOrFolder(imgPath, false).file;
            // console.log('folderName*******', folderName);
            const newestPngFile =
                _.getMostRecentPNGFileOrFolder(path.join( imgPath + '/' + folderName), true, indexImage);


            const mrF = path.join( imgPath + '/' + folderName + '/' + newestPngFile.file);
            // console.log('newestPngFile*******', mrF);
            contents = await fs.promises.readFile(mrF, {encoding: 'base64'});

            const mrJSon = path.join( imgPath + '/' + folderName + '/' + newestPngFile.file).replace('.png', '.json');

            try {
                json = await fs.promises.readFile(mrJSon, {encoding: 'utf8'});

            } catch (err) {
                json = {};
            }


            return {imageBase64: contents, json};
        } catch (err) {
            return {err}
        }
    },
    oldDatas: null,
    webRootPath: '/',
    cnt: 0
}

module.exports = _;

partials/back-to-top-button.hbs :
<button class="c-button c-back-to-top js_backToTop" data-aos-offset="-800px" data-aos="zoom-out-up"
        type="button" title="Zurück zum Anfang">
    <svg aria-hidden="true" focusable="false" version="1.1" xmlns="http://www.w3.org/2000/svg"
         xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
         width="34px" height="38px" viewBox="0 0 34 38" xml:space="preserve">
<path fill="#4D4D4C"
      d="M14.746,38l0-29.35L3.173,20.291L0,17.1L17,0l17,17.1l-3.176,3.195L19.241,8.643l0,29.35L14.746,38z"/>
</svg>

</button>

